/* tslint:disable */
/* eslint-disable */
/**
 * Typesense API
 * An open source search engine for building delightful search experiences.
 *
 * The version of the OpenAPI document: 30.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DeleteDocuments200Response,
  DeleteDocumentsDeleteDocumentsParametersParameter,
  DirtyValues,
  ExportDocumentsExportDocumentsParametersParameter,
  ImportDocumentsImportDocumentsParametersParameter,
  IndexAction,
  ModelApiResponse,
  MultiSearchParameters,
  MultiSearchResult,
  MultiSearchSearchesParameter,
  SearchParameters,
  SearchResult,
  UpdateDocuments200Response,
  UpdateDocumentsUpdateDocumentsParametersParameter,
} from '../models/index';
import {
    DeleteDocuments200ResponseFromJSON,
    DeleteDocuments200ResponseToJSON,
    DeleteDocumentsDeleteDocumentsParametersParameterFromJSON,
    DeleteDocumentsDeleteDocumentsParametersParameterToJSON,
    DirtyValuesFromJSON,
    DirtyValuesToJSON,
    ExportDocumentsExportDocumentsParametersParameterFromJSON,
    ExportDocumentsExportDocumentsParametersParameterToJSON,
    ImportDocumentsImportDocumentsParametersParameterFromJSON,
    ImportDocumentsImportDocumentsParametersParameterToJSON,
    IndexActionFromJSON,
    IndexActionToJSON,
    ModelApiResponseFromJSON,
    ModelApiResponseToJSON,
    MultiSearchParametersFromJSON,
    MultiSearchParametersToJSON,
    MultiSearchResultFromJSON,
    MultiSearchResultToJSON,
    MultiSearchSearchesParameterFromJSON,
    MultiSearchSearchesParameterToJSON,
    SearchParametersFromJSON,
    SearchParametersToJSON,
    SearchResultFromJSON,
    SearchResultToJSON,
    UpdateDocuments200ResponseFromJSON,
    UpdateDocuments200ResponseToJSON,
    UpdateDocumentsUpdateDocumentsParametersParameterFromJSON,
    UpdateDocumentsUpdateDocumentsParametersParameterToJSON,
} from '../models/index';

import {removeUndefined} from "../../utils/api";

export interface DeleteDocumentRequest {
    collectionName: string;
    documentId: string;
}

export interface DeleteDocumentsRequest {
    collectionName: string;
    deleteDocumentsParameters?: DeleteDocumentsDeleteDocumentsParametersParameter;
}

export interface ExportDocumentsRequest {
    collectionName: string;
    exportDocumentsParameters?: ExportDocumentsExportDocumentsParametersParameter;
}

export interface GetDocumentRequest {
    collectionName: string;
    documentId: string;
}

export interface ImportDocumentsRequest {
    collectionName: string;
    body: string;
    importDocumentsParameters?: ImportDocumentsImportDocumentsParametersParameter;
}

export interface IndexDocumentRequest {
    collectionName: string;
    body: object;
    action?: IndexAction;
    dirtyValues?: DirtyValues;
}

export interface MultiSearchRequest {
    multiSearchParameters: MultiSearchParameters;
    multiSearchSearchesParameter?: MultiSearchSearchesParameter;
}

export interface SearchCollectionRequest {
    collectionName: string;
    searchParameters: SearchParameters;
}

export interface UpdateDocumentRequest {
    collectionName: string;
    documentId: string;
    body: object;
    dirtyValues?: DirtyValues;
}

export interface UpdateDocumentsRequest {
    collectionName: string;
    body: object;
    updateDocumentsParameters?: UpdateDocumentsUpdateDocumentsParametersParameter;
}

/**
 *
 */
export class DocumentsApi extends runtime.BaseAPI {

    /**
     * Delete an individual document from a collection by using its ID.
     * Delete a document
     */
    async deleteDocumentRaw(requestParameters: DeleteDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['collectionName'] == null) {
            throw new runtime.RequiredError(
                'collectionName',
                'Required parameter "collectionName" was null or undefined when calling deleteDocument().'
            );
        }

        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling deleteDocument().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/collections/{collectionName}/documents/{documentId}`;
        urlPath = urlPath.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters['collectionName'])));
        urlPath = urlPath.replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete an individual document from a collection by using its ID.
     * Delete a document
     */
    async deleteDocument(requestParameters: DeleteDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a bunch of documents that match a specific filter condition. Use the `batch_size` parameter to control the number of documents that should deleted at a time. A larger value will speed up deletions, but will impact performance of other operations running on the server.
     * Delete a bunch of documents
     */
    async deleteDocumentsRaw(requestParameters: DeleteDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteDocuments200Response>> {
        if (requestParameters['collectionName'] == null) {
            throw new runtime.RequiredError(
                'collectionName',
                'Required parameter "collectionName" was null or undefined when calling deleteDocuments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['deleteDocumentsParameters'] != null) {
            queryParameters['deleteDocumentsParameters'] = requestParameters['deleteDocumentsParameters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/collections/{collectionName}/documents`;
        urlPath = urlPath.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters['collectionName'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteDocuments200ResponseFromJSON(jsonValue));
    }

    /**
     * Delete a bunch of documents that match a specific filter condition. Use the `batch_size` parameter to control the number of documents that should deleted at a time. A larger value will speed up deletions, but will impact performance of other operations running on the server.
     * Delete a bunch of documents
     */
    async deleteDocuments(requestParameters: DeleteDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteDocuments200Response> {
        const response = await this.deleteDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export all documents in a collection in JSON lines format.
     * Export all documents in a collection
     */
    async exportDocumentsRaw(requestParameters: ExportDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['collectionName'] == null) {
            throw new runtime.RequiredError(
                'collectionName',
                'Required parameter "collectionName" was null or undefined when calling exportDocuments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['exportDocumentsParameters'] != null) {
            queryParameters['exportDocumentsParameters'] = requestParameters['exportDocumentsParameters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/collections/{collectionName}/documents/export`;
        urlPath = urlPath.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters['collectionName'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Export all documents in a collection in JSON lines format.
     * Export all documents in a collection
     */
    async exportDocuments(requestParameters: ExportDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch an individual document from a collection by using its ID.
     * Retrieve a document
     */
    async getDocumentRaw(requestParameters: GetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['collectionName'] == null) {
            throw new runtime.RequiredError(
                'collectionName',
                'Required parameter "collectionName" was null or undefined when calling getDocument().'
            );
        }

        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling getDocument().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/collections/{collectionName}/documents/{documentId}`;
        urlPath = urlPath.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters['collectionName'])));
        urlPath = urlPath.replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetch an individual document from a collection by using its ID.
     * Retrieve a document
     */
    async getDocument(requestParameters: GetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The documents to be imported must be formatted in a newline delimited JSON structure. You can feed the output file from a Typesense export operation directly as import.
     * Import documents into a collection
     */
    async importDocumentsRaw(requestParameters: ImportDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['collectionName'] == null) {
            throw new runtime.RequiredError(
                'collectionName',
                'Required parameter "collectionName" was null or undefined when calling importDocuments().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling importDocuments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['importDocumentsParameters'] != null) {
            queryParameters['importDocumentsParameters'] = requestParameters['importDocumentsParameters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/collections/{collectionName}/documents/import`;
        urlPath = urlPath.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters['collectionName'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * The documents to be imported must be formatted in a newline delimited JSON structure. You can feed the output file from a Typesense export operation directly as import.
     * Import documents into a collection
     */
    async importDocuments(requestParameters: ImportDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.importDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A document to be indexed in a given collection must conform to the schema of the collection.
     * Index a document
     */
    async indexDocumentRaw(requestParameters: IndexDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['collectionName'] == null) {
            throw new runtime.RequiredError(
                'collectionName',
                'Required parameter "collectionName" was null or undefined when calling indexDocument().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling indexDocument().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['action'] != null) {
            queryParameters['action'] = requestParameters['action'];
        }

        if (requestParameters['dirtyValues'] != null) {
            queryParameters['dirty_values'] = requestParameters['dirtyValues'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/collections/{collectionName}/documents`;
        urlPath = urlPath.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters['collectionName'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * A document to be indexed in a given collection must conform to the schema of the collection.
     * Index a document
     */
    async indexDocument(requestParameters: IndexDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.indexDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This is especially useful to avoid round-trip network latencies incurred otherwise if each of these requests are sent in separate HTTP requests. You can also use this feature to do a federated search across multiple collections in a single HTTP request.
     * send multiple search requests in a single HTTP request
     */
    async multiSearchRaw(requestParameters: MultiSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiSearchResult>> {
        if (requestParameters['multiSearchParameters'] == null) {
            throw new runtime.RequiredError(
                'multiSearchParameters',
                'Required parameter "multiSearchParameters" was null or undefined when calling multiSearch().'
            );
        }

        let queryParameters: any = {};

        if (requestParameters['multiSearchParameters'] != null) {
          queryParameters = removeUndefined(MultiSearchParametersToJSON(requestParameters.multiSearchParameters));
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/multi_search`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MultiSearchSearchesParameterToJSON(requestParameters['multiSearchSearchesParameter']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MultiSearchResultFromJSON(jsonValue));
    }

    /**
     * This is especially useful to avoid round-trip network latencies incurred otherwise if each of these requests are sent in separate HTTP requests. You can also use this feature to do a federated search across multiple collections in a single HTTP request.
     * send multiple search requests in a single HTTP request
     */
    async multiSearch(requestParameters: MultiSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiSearchResult> {
        const response = await this.multiSearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for documents in a collection that match the search criteria.
     * Search for documents in a collection
     */
    async searchCollectionRaw(requestParameters: SearchCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResult>> {
        if (requestParameters['collectionName'] == null) {
            throw new runtime.RequiredError(
                'collectionName',
                'Required parameter "collectionName" was null or undefined when calling searchCollection().'
            );
        }

        if (requestParameters['searchParameters'] == null) {
            throw new runtime.RequiredError(
                'searchParameters',
                'Required parameter "searchParameters" was null or undefined when calling searchCollection().'
            );
        }

        let queryParameters: any = {};

        if (requestParameters['searchParameters'] != null) {
          queryParameters = removeUndefined(SearchParametersToJSON(requestParameters.searchParameters));
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/collections/{collectionName}/documents/search`;
        urlPath = urlPath.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters['collectionName'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchResultFromJSON(jsonValue));
    }

    /**
     * Search for documents in a collection that match the search criteria.
     * Search for documents in a collection
     */
    async searchCollection(requestParameters: SearchCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResult> {
        const response = await this.searchCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an individual document from a collection by using its ID. The update can be partial.
     * Update a document
     */
    async updateDocumentRaw(requestParameters: UpdateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['collectionName'] == null) {
            throw new runtime.RequiredError(
                'collectionName',
                'Required parameter "collectionName" was null or undefined when calling updateDocument().'
            );
        }

        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling updateDocument().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateDocument().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dirtyValues'] != null) {
            queryParameters['dirty_values'] = requestParameters['dirtyValues'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/collections/{collectionName}/documents/{documentId}`;
        urlPath = urlPath.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters['collectionName'])));
        urlPath = urlPath.replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Update an individual document from a collection by using its ID. The update can be partial.
     * Update a document
     */
    async updateDocument(requestParameters: UpdateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The filter_by query parameter is used to filter to specify a condition against which the documents are matched. The request body contains the fields that should be updated for any documents that match the filter condition. This endpoint is only available if the Typesense server is version `0.25.0.rc12` or later.
     * Update documents with conditional query
     */
    async updateDocumentsRaw(requestParameters: UpdateDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateDocuments200Response>> {
        if (requestParameters['collectionName'] == null) {
            throw new runtime.RequiredError(
                'collectionName',
                'Required parameter "collectionName" was null or undefined when calling updateDocuments().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateDocuments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['updateDocumentsParameters'] != null) {
            queryParameters['updateDocumentsParameters'] = requestParameters['updateDocumentsParameters'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/collections/{collectionName}/documents`;
        urlPath = urlPath.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters['collectionName'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateDocuments200ResponseFromJSON(jsonValue));
    }

    /**
     * The filter_by query parameter is used to filter to specify a condition against which the documents are matched. The request body contains the fields that should be updated for any documents that match the filter condition. This endpoint is only available if the Typesense server is version `0.25.0.rc12` or later.
     * Update documents with conditional query
     */
    async updateDocuments(requestParameters: UpdateDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateDocuments200Response> {
        const response = await this.updateDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
