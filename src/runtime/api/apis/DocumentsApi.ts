/* tslint:disable */
/* eslint-disable */
/**
 * Typesense API
 * An open source search engine for building delightful search experiences.
 *
 * The version of the OpenAPI document: 0.24.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DeleteDocuments200Response,
  DeleteDocumentsDeleteDocumentsParametersParameter,
  ExportDocumentsExportDocumentsParametersParameter,
  ImportDocumentsImportDocumentsParametersParameter,
  ModelApiResponse,
  MultiSearchParameters,
  MultiSearchResult,
  MultiSearchSearchesParameter,
  SearchOverride,
  SearchOverrideSchema,
  SearchOverridesResponse,
  SearchParameters,
  SearchResult,
  SearchSynonym,
  SearchSynonymSchema,
  SearchSynonymsResponse,
  UpdateDocuments200Response,
  UpdateDocumentsUpdateDocumentsParametersParameter,
} from '../models';
import {
    DeleteDocuments200ResponseFromJSON,
    DeleteDocuments200ResponseToJSON,
    DeleteDocumentsDeleteDocumentsParametersParameterFromJSON,
    DeleteDocumentsDeleteDocumentsParametersParameterToJSON,
    ExportDocumentsExportDocumentsParametersParameterFromJSON,
    ExportDocumentsExportDocumentsParametersParameterToJSON,
    ImportDocumentsImportDocumentsParametersParameterFromJSON,
    ImportDocumentsImportDocumentsParametersParameterToJSON,
    ModelApiResponseFromJSON,
    ModelApiResponseToJSON,
    MultiSearchParametersFromJSON,
    MultiSearchParametersToJSON,
    MultiSearchResultFromJSON,
    MultiSearchResultToJSON,
    MultiSearchSearchesParameterFromJSON,
    MultiSearchSearchesParameterToJSON,
    SearchOverrideFromJSON,
    SearchOverrideToJSON,
    SearchOverrideSchemaFromJSON,
    SearchOverrideSchemaToJSON,
    SearchOverridesResponseFromJSON,
    SearchOverridesResponseToJSON,
    SearchParametersFromJSON,
    SearchParametersToJSON,
    SearchResultFromJSON,
    SearchResultToJSON,
    SearchSynonymFromJSON,
    SearchSynonymToJSON,
    SearchSynonymSchemaFromJSON,
    SearchSynonymSchemaToJSON,
    SearchSynonymsResponseFromJSON,
    SearchSynonymsResponseToJSON,
    UpdateDocuments200ResponseFromJSON,
    UpdateDocuments200ResponseToJSON,
    UpdateDocumentsUpdateDocumentsParametersParameterFromJSON,
    UpdateDocumentsUpdateDocumentsParametersParameterToJSON,
} from '../models';

export interface DeleteDocumentRequest {
    collectionName: string;
    documentId: string;
}

export interface DeleteDocumentsRequest {
    collectionName: string;
    deleteDocumentsParameters?: DeleteDocumentsDeleteDocumentsParametersParameter;
}

export interface DeleteSearchOverrideRequest {
    collectionName: string;
    overrideId: string;
}

export interface DeleteSearchSynonymRequest {
    collectionName: string;
    synonymId: string;
}

export interface ExportDocumentsRequest {
    collectionName: string;
    exportDocumentsParameters?: ExportDocumentsExportDocumentsParametersParameter;
}

export interface GetDocumentRequest {
    collectionName: string;
    documentId: string;
}

export interface GetSearchOverrideRequest {
    collectionName: string;
    overrideId: string;
}

export interface GetSearchOverridesRequest {
    collectionName: string;
}

export interface GetSearchSynonymRequest {
    collectionName: string;
    synonymId: string;
}

export interface GetSearchSynonymsRequest {
    collectionName: string;
}

export interface ImportDocumentsRequest {
    collectionName: string;
    body: string;
    importDocumentsParameters?: ImportDocumentsImportDocumentsParametersParameter;
}

export interface IndexDocumentRequest {
    collectionName: string;
    body: object;
    action?: IndexDocumentActionEnum;
}

export interface MultiSearchRequest {
    multiSearchParameters: MultiSearchParameters;
    multiSearchSearchesParameter?: MultiSearchSearchesParameter;
}

export interface SearchCollectionRequest {
    collectionName: string;
    searchParameters: SearchParameters;
}

export interface UpdateDocumentRequest {
    collectionName: string;
    documentId: string;
    body: object;
}

export interface UpdateDocumentsRequest {
    collectionName: string;
    body: object;
    updateDocumentsParameters?: UpdateDocumentsUpdateDocumentsParametersParameter;
}

export interface UpsertSearchOverrideRequest {
    collectionName: string;
    overrideId: string;
    searchOverrideSchema: SearchOverrideSchema;
}

export interface UpsertSearchSynonymRequest {
    collectionName: string;
    synonymId: string;
    searchSynonymSchema: SearchSynonymSchema;
}

/**
 * 
 */
export class DocumentsApi extends runtime.BaseAPI {

    /**
     * Delete an individual document from a collection by using its ID.
     * Delete a document
     */
    async deleteDocumentRaw(requestParameters: DeleteDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling deleteDocument.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling deleteDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/documents/{documentId}`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))).replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete an individual document from a collection by using its ID.
     * Delete a document
     */
    async deleteDocument(requestParameters: DeleteDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a bunch of documents that match a specific filter condition. Use the `batch_size` parameter to control the number of documents that should deleted at a time. A larger value will speed up deletions, but will impact performance of other operations running on the server.
     * Delete a bunch of documents
     */
    async deleteDocumentsRaw(requestParameters: DeleteDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteDocuments200Response>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling deleteDocuments.');
        }

        const queryParameters: any = {};

        if (requestParameters.deleteDocumentsParameters !== undefined) {
            queryParameters['deleteDocumentsParameters'] = requestParameters.deleteDocumentsParameters;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/documents`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteDocuments200ResponseFromJSON(jsonValue));
    }

    /**
     * Delete a bunch of documents that match a specific filter condition. Use the `batch_size` parameter to control the number of documents that should deleted at a time. A larger value will speed up deletions, but will impact performance of other operations running on the server.
     * Delete a bunch of documents
     */
    async deleteDocuments(requestParameters: DeleteDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteDocuments200Response> {
        const response = await this.deleteDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an override associated with a collection
     */
    async deleteSearchOverrideRaw(requestParameters: DeleteSearchOverrideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchOverride>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling deleteSearchOverride.');
        }

        if (requestParameters.overrideId === null || requestParameters.overrideId === undefined) {
            throw new runtime.RequiredError('overrideId','Required parameter requestParameters.overrideId was null or undefined when calling deleteSearchOverride.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/overrides/{overrideId}`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))).replace(`{${"overrideId"}}`, encodeURIComponent(String(requestParameters.overrideId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchOverrideFromJSON(jsonValue));
    }

    /**
     * Delete an override associated with a collection
     */
    async deleteSearchOverride(requestParameters: DeleteSearchOverrideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchOverride> {
        const response = await this.deleteSearchOverrideRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a synonym associated with a collection
     */
    async deleteSearchSynonymRaw(requestParameters: DeleteSearchSynonymRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchSynonym>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling deleteSearchSynonym.');
        }

        if (requestParameters.synonymId === null || requestParameters.synonymId === undefined) {
            throw new runtime.RequiredError('synonymId','Required parameter requestParameters.synonymId was null or undefined when calling deleteSearchSynonym.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/synonyms/{synonymId}`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))).replace(`{${"synonymId"}}`, encodeURIComponent(String(requestParameters.synonymId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchSynonymFromJSON(jsonValue));
    }

    /**
     * Delete a synonym associated with a collection
     */
    async deleteSearchSynonym(requestParameters: DeleteSearchSynonymRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchSynonym> {
        const response = await this.deleteSearchSynonymRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export all documents in a collection in JSON lines format.
     * Export all documents in a collection
     */
    async exportDocumentsRaw(requestParameters: ExportDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling exportDocuments.');
        }

        const queryParameters: any = {};

        if (requestParameters.exportDocumentsParameters !== undefined) {
            queryParameters['exportDocumentsParameters'] = requestParameters.exportDocumentsParameters;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/documents/export`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Export all documents in a collection in JSON lines format.
     * Export all documents in a collection
     */
    async exportDocuments(requestParameters: ExportDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch an individual document from a collection by using its ID.
     * Retreive a document
     */
    async getDocumentRaw(requestParameters: GetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling getDocument.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling getDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/documents/{documentId}`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))).replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetch an individual document from a collection by using its ID.
     * Retreive a document
     */
    async getDocument(requestParameters: GetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the details of a search override, given its id.
     * Retrieve a single search override
     */
    async getSearchOverrideRaw(requestParameters: GetSearchOverrideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchOverride>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling getSearchOverride.');
        }

        if (requestParameters.overrideId === null || requestParameters.overrideId === undefined) {
            throw new runtime.RequiredError('overrideId','Required parameter requestParameters.overrideId was null or undefined when calling getSearchOverride.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/overrides/{overrideId}`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))).replace(`{${"overrideId"}}`, encodeURIComponent(String(requestParameters.overrideId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchOverrideFromJSON(jsonValue));
    }

    /**
     * Retrieve the details of a search override, given its id.
     * Retrieve a single search override
     */
    async getSearchOverride(requestParameters: GetSearchOverrideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchOverride> {
        const response = await this.getSearchOverrideRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all collection overrides
     */
    async getSearchOverridesRaw(requestParameters: GetSearchOverridesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchOverridesResponse>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling getSearchOverrides.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/overrides`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchOverridesResponseFromJSON(jsonValue));
    }

    /**
     * List all collection overrides
     */
    async getSearchOverrides(requestParameters: GetSearchOverridesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchOverridesResponse> {
        const response = await this.getSearchOverridesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the details of a search synonym, given its id.
     * Retrieve a single search synonym
     */
    async getSearchSynonymRaw(requestParameters: GetSearchSynonymRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchSynonym>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling getSearchSynonym.');
        }

        if (requestParameters.synonymId === null || requestParameters.synonymId === undefined) {
            throw new runtime.RequiredError('synonymId','Required parameter requestParameters.synonymId was null or undefined when calling getSearchSynonym.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/synonyms/{synonymId}`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))).replace(`{${"synonymId"}}`, encodeURIComponent(String(requestParameters.synonymId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchSynonymFromJSON(jsonValue));
    }

    /**
     * Retrieve the details of a search synonym, given its id.
     * Retrieve a single search synonym
     */
    async getSearchSynonym(requestParameters: GetSearchSynonymRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchSynonym> {
        const response = await this.getSearchSynonymRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all collection synonyms
     */
    async getSearchSynonymsRaw(requestParameters: GetSearchSynonymsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchSynonymsResponse>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling getSearchSynonyms.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/synonyms`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchSynonymsResponseFromJSON(jsonValue));
    }

    /**
     * List all collection synonyms
     */
    async getSearchSynonyms(requestParameters: GetSearchSynonymsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchSynonymsResponse> {
        const response = await this.getSearchSynonymsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The documents to be imported must be formatted in a newline delimited JSON structure. You can feed the output file from a Typesense export operation directly as import.
     * Import documents into a collection
     */
    async importDocumentsRaw(requestParameters: ImportDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling importDocuments.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling importDocuments.');
        }

        const queryParameters: any = {};

        if (requestParameters.importDocumentsParameters !== undefined) {
            queryParameters['importDocumentsParameters'] = requestParameters.importDocumentsParameters;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/documents/import`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * The documents to be imported must be formatted in a newline delimited JSON structure. You can feed the output file from a Typesense export operation directly as import.
     * Import documents into a collection
     */
    async importDocuments(requestParameters: ImportDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.importDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A document to be indexed in a given collection must conform to the schema of the collection.
     * Index a document
     */
    async indexDocumentRaw(requestParameters: IndexDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling indexDocument.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling indexDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.action !== undefined) {
            queryParameters['action'] = requestParameters.action;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/documents`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * A document to be indexed in a given collection must conform to the schema of the collection.
     * Index a document
     */
    async indexDocument(requestParameters: IndexDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.indexDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This is especially useful to avoid round-trip network latencies incurred otherwise if each of these requests are sent in separate HTTP requests. You can also use this feature to do a federated search across multiple collections in a single HTTP request.
     * send multiple search requests in a single HTTP request
     */
    async multiSearchRaw(requestParameters: MultiSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiSearchResult>> {
        if (requestParameters.multiSearchParameters === null || requestParameters.multiSearchParameters === undefined) {
            throw new runtime.RequiredError('multiSearchParameters','Required parameter requestParameters.multiSearchParameters was null or undefined when calling multiSearch.');
        }

        const queryParameters: any = {};

        if (requestParameters.multiSearchParameters !== undefined) {
            queryParameters['multiSearchParameters'] = requestParameters.multiSearchParameters;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/multi_search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MultiSearchSearchesParameterToJSON(requestParameters.multiSearchSearchesParameter),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MultiSearchResultFromJSON(jsonValue));
    }

    /**
     * This is especially useful to avoid round-trip network latencies incurred otherwise if each of these requests are sent in separate HTTP requests. You can also use this feature to do a federated search across multiple collections in a single HTTP request.
     * send multiple search requests in a single HTTP request
     */
    async multiSearch(requestParameters: MultiSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiSearchResult> {
        const response = await this.multiSearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for documents in a collection that match the search criteria.
     * Search for documents in a collection
     */
    async searchCollectionRaw(requestParameters: SearchCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResult>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling searchCollection.');
        }

        if (requestParameters.searchParameters === null || requestParameters.searchParameters === undefined) {
            throw new runtime.RequiredError('searchParameters','Required parameter requestParameters.searchParameters was null or undefined when calling searchCollection.');
        }

        const queryParameters: any = {};

        if (requestParameters.searchParameters !== undefined) {
            queryParameters['searchParameters'] = requestParameters.searchParameters;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/documents/search`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchResultFromJSON(jsonValue));
    }

    /**
     * Search for documents in a collection that match the search criteria.
     * Search for documents in a collection
     */
    async searchCollection(requestParameters: SearchCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResult> {
        const response = await this.searchCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an individual document from a collection by using its ID. The update can be partial.
     * Update a document
     */
    async updateDocumentRaw(requestParameters: UpdateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling updateDocument.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling updateDocument.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/documents/{documentId}`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))).replace(`{${"documentId"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Update an individual document from a collection by using its ID. The update can be partial.
     * Update a document
     */
    async updateDocument(requestParameters: UpdateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The filter_by query parameter is used to filter to specify a condition against which the documents are matched. The request body contains the fields that should be updated for any documents that match the filter condition. This endpoint is only available if the Typesense server is version `0.25.0.rc12` or later.
     * Update documents with conditional query
     */
    async updateDocumentsRaw(requestParameters: UpdateDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateDocuments200Response>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling updateDocuments.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateDocuments.');
        }

        const queryParameters: any = {};

        if (requestParameters.updateDocumentsParameters !== undefined) {
            queryParameters['updateDocumentsParameters'] = requestParameters.updateDocumentsParameters;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/documents`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateDocuments200ResponseFromJSON(jsonValue));
    }

    /**
     * The filter_by query parameter is used to filter to specify a condition against which the documents are matched. The request body contains the fields that should be updated for any documents that match the filter condition. This endpoint is only available if the Typesense server is version `0.25.0.rc12` or later.
     * Update documents with conditional query
     */
    async updateDocuments(requestParameters: UpdateDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateDocuments200Response> {
        const response = await this.updateDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create or update an override to promote certain documents over others. Using overrides, you can include or exclude specific documents for a given query.
     * Create or update an override to promote certain documents over others
     */
    async upsertSearchOverrideRaw(requestParameters: UpsertSearchOverrideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchOverride>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling upsertSearchOverride.');
        }

        if (requestParameters.overrideId === null || requestParameters.overrideId === undefined) {
            throw new runtime.RequiredError('overrideId','Required parameter requestParameters.overrideId was null or undefined when calling upsertSearchOverride.');
        }

        if (requestParameters.searchOverrideSchema === null || requestParameters.searchOverrideSchema === undefined) {
            throw new runtime.RequiredError('searchOverrideSchema','Required parameter requestParameters.searchOverrideSchema was null or undefined when calling upsertSearchOverride.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/overrides/{overrideId}`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))).replace(`{${"overrideId"}}`, encodeURIComponent(String(requestParameters.overrideId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SearchOverrideSchemaToJSON(requestParameters.searchOverrideSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchOverrideFromJSON(jsonValue));
    }

    /**
     * Create or update an override to promote certain documents over others. Using overrides, you can include or exclude specific documents for a given query.
     * Create or update an override to promote certain documents over others
     */
    async upsertSearchOverride(requestParameters: UpsertSearchOverrideRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchOverride> {
        const response = await this.upsertSearchOverrideRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create or update a synonym  to define search terms that should be considered equivalent.
     * Create or update a synonym
     */
    async upsertSearchSynonymRaw(requestParameters: UpsertSearchSynonymRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchSynonym>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling upsertSearchSynonym.');
        }

        if (requestParameters.synonymId === null || requestParameters.synonymId === undefined) {
            throw new runtime.RequiredError('synonymId','Required parameter requestParameters.synonymId was null or undefined when calling upsertSearchSynonym.');
        }

        if (requestParameters.searchSynonymSchema === null || requestParameters.searchSynonymSchema === undefined) {
            throw new runtime.RequiredError('searchSynonymSchema','Required parameter requestParameters.searchSynonymSchema was null or undefined when calling upsertSearchSynonym.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}/synonyms/{synonymId}`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))).replace(`{${"synonymId"}}`, encodeURIComponent(String(requestParameters.synonymId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SearchSynonymSchemaToJSON(requestParameters.searchSynonymSchema),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchSynonymFromJSON(jsonValue));
    }

    /**
     * Create or update a synonym  to define search terms that should be considered equivalent.
     * Create or update a synonym
     */
    async upsertSearchSynonym(requestParameters: UpsertSearchSynonymRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchSynonym> {
        const response = await this.upsertSearchSynonymRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const IndexDocumentActionEnum = {
    Upsert: 'upsert'
} as const;
export type IndexDocumentActionEnum = typeof IndexDocumentActionEnum[keyof typeof IndexDocumentActionEnum];
