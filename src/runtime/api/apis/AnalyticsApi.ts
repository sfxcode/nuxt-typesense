/* tslint:disable */
/* eslint-disable */
/**
 * Typesense API
 * An open source search engine for building delightful search experiences.
 *
 * The version of the OpenAPI document: 30.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AnalyticsEvent,
  AnalyticsEventCreateResponse,
  AnalyticsEventsResponse,
  AnalyticsRule,
  AnalyticsRuleUpdate,
  AnalyticsStatus,
  CreateAnalyticsRule200Response,
  CreateAnalyticsRuleRequest,
  ModelApiResponse,
} from '../models/index';
import {
    AnalyticsEventFromJSON,
    AnalyticsEventToJSON,
    AnalyticsEventCreateResponseFromJSON,
    AnalyticsEventCreateResponseToJSON,
    AnalyticsEventsResponseFromJSON,
    AnalyticsEventsResponseToJSON,
    AnalyticsRuleFromJSON,
    AnalyticsRuleToJSON,
    AnalyticsRuleUpdateFromJSON,
    AnalyticsRuleUpdateToJSON,
    AnalyticsStatusFromJSON,
    AnalyticsStatusToJSON,
    CreateAnalyticsRule200ResponseFromJSON,
    CreateAnalyticsRule200ResponseToJSON,
    CreateAnalyticsRuleRequestFromJSON,
    CreateAnalyticsRuleRequestToJSON,
    ModelApiResponseFromJSON,
    ModelApiResponseToJSON,
} from '../models/index';

export interface CreateAnalyticsEventRequest {
    analyticsEvent: AnalyticsEvent;
}

export interface CreateAnalyticsRuleOperationRequest {
    createAnalyticsRuleRequest: CreateAnalyticsRuleRequest;
}

export interface DeleteAnalyticsRuleRequest {
    ruleName: string;
}

export interface GetAnalyticsEventsRequest {
    userId: string;
    name: string;
    n: number;
}

export interface RetrieveAnalyticsRuleRequest {
    ruleName: string;
}

export interface RetrieveAnalyticsRulesRequest {
    ruleTag?: string;
}

export interface UpsertAnalyticsRuleRequest {
    ruleName: string;
    analyticsRuleUpdate: AnalyticsRuleUpdate;
}

/**
 * 
 */
export class AnalyticsApi extends runtime.BaseAPI {

    /**
     * Submit a single analytics event. The event must correspond to an existing analytics rule by name.
     * Create an analytics event
     */
    async createAnalyticsEventRaw(requestParameters: CreateAnalyticsEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnalyticsEventCreateResponse>> {
        if (requestParameters['analyticsEvent'] == null) {
            throw new runtime.RequiredError(
                'analyticsEvent',
                'Required parameter "analyticsEvent" was null or undefined when calling createAnalyticsEvent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/analytics/events`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AnalyticsEventToJSON(requestParameters['analyticsEvent']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalyticsEventCreateResponseFromJSON(jsonValue));
    }

    /**
     * Submit a single analytics event. The event must correspond to an existing analytics rule by name.
     * Create an analytics event
     */
    async createAnalyticsEvent(requestParameters: CreateAnalyticsEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnalyticsEventCreateResponse> {
        const response = await this.createAnalyticsEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create one or more analytics rules. You can send a single rule object or an array of rule objects.
     * Create analytics rule(s)
     */
    async createAnalyticsRuleRaw(requestParameters: CreateAnalyticsRuleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateAnalyticsRule200Response>> {
        if (requestParameters['createAnalyticsRuleRequest'] == null) {
            throw new runtime.RequiredError(
                'createAnalyticsRuleRequest',
                'Required parameter "createAnalyticsRuleRequest" was null or undefined when calling createAnalyticsRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/analytics/rules`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAnalyticsRuleRequestToJSON(requestParameters['createAnalyticsRuleRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateAnalyticsRule200ResponseFromJSON(jsonValue));
    }

    /**
     * Create one or more analytics rules. You can send a single rule object or an array of rule objects.
     * Create analytics rule(s)
     */
    async createAnalyticsRule(requestParameters: CreateAnalyticsRuleOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateAnalyticsRule200Response> {
        const response = await this.createAnalyticsRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Permanently deletes an analytics rule, given it\'s name
     * Delete an analytics rule
     */
    async deleteAnalyticsRuleRaw(requestParameters: DeleteAnalyticsRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnalyticsRule>> {
        if (requestParameters['ruleName'] == null) {
            throw new runtime.RequiredError(
                'ruleName',
                'Required parameter "ruleName" was null or undefined when calling deleteAnalyticsRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/analytics/rules/{ruleName}`;
        urlPath = urlPath.replace(`{${"ruleName"}}`, encodeURIComponent(String(requestParameters['ruleName'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalyticsRuleFromJSON(jsonValue));
    }

    /**
     * Permanently deletes an analytics rule, given it\'s name
     * Delete an analytics rule
     */
    async deleteAnalyticsRule(requestParameters: DeleteAnalyticsRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnalyticsRule> {
        const response = await this.deleteAnalyticsRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Triggers a flush of analytics data to persistent storage.
     * Flush in-memory analytics to disk
     */
    async flushAnalyticsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnalyticsEventCreateResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/analytics/flush`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalyticsEventCreateResponseFromJSON(jsonValue));
    }

    /**
     * Triggers a flush of analytics data to persistent storage.
     * Flush in-memory analytics to disk
     */
    async flushAnalytics(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnalyticsEventCreateResponse> {
        const response = await this.flushAnalyticsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the most recent events for a user and rule.
     * Retrieve analytics events
     */
    async getAnalyticsEventsRaw(requestParameters: GetAnalyticsEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnalyticsEventsResponse>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling getAnalyticsEvents().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getAnalyticsEvents().'
            );
        }

        if (requestParameters['n'] == null) {
            throw new runtime.RequiredError(
                'n',
                'Required parameter "n" was null or undefined when calling getAnalyticsEvents().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['userId'] != null) {
            queryParameters['user_id'] = requestParameters['userId'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['n'] != null) {
            queryParameters['n'] = requestParameters['n'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/analytics/events`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalyticsEventsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the most recent events for a user and rule.
     * Retrieve analytics events
     */
    async getAnalyticsEvents(requestParameters: GetAnalyticsEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnalyticsEventsResponse> {
        const response = await this.getAnalyticsEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns sizes of internal analytics buffers and queues.
     * Get analytics subsystem status
     */
    async getAnalyticsStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnalyticsStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/analytics/status`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalyticsStatusFromJSON(jsonValue));
    }

    /**
     * Returns sizes of internal analytics buffers and queues.
     * Get analytics subsystem status
     */
    async getAnalyticsStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnalyticsStatus> {
        const response = await this.getAnalyticsStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the details of an analytics rule, given it\'s name
     * Retrieves an analytics rule
     */
    async retrieveAnalyticsRuleRaw(requestParameters: RetrieveAnalyticsRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnalyticsRule>> {
        if (requestParameters['ruleName'] == null) {
            throw new runtime.RequiredError(
                'ruleName',
                'Required parameter "ruleName" was null or undefined when calling retrieveAnalyticsRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/analytics/rules/{ruleName}`;
        urlPath = urlPath.replace(`{${"ruleName"}}`, encodeURIComponent(String(requestParameters['ruleName'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalyticsRuleFromJSON(jsonValue));
    }

    /**
     * Retrieve the details of an analytics rule, given it\'s name
     * Retrieves an analytics rule
     */
    async retrieveAnalyticsRule(requestParameters: RetrieveAnalyticsRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnalyticsRule> {
        const response = await this.retrieveAnalyticsRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all analytics rules. Use the optional rule_tag filter to narrow down results.
     * Retrieve analytics rules
     */
    async retrieveAnalyticsRulesRaw(requestParameters: RetrieveAnalyticsRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AnalyticsRule>>> {
        const queryParameters: any = {};

        if (requestParameters['ruleTag'] != null) {
            queryParameters['rule_tag'] = requestParameters['ruleTag'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/analytics/rules`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AnalyticsRuleFromJSON));
    }

    /**
     * Retrieve all analytics rules. Use the optional rule_tag filter to narrow down results.
     * Retrieve analytics rules
     */
    async retrieveAnalyticsRules(requestParameters: RetrieveAnalyticsRulesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AnalyticsRule>> {
        const response = await this.retrieveAnalyticsRulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upserts an analytics rule with the given name.
     * Upserts an analytics rule
     */
    async upsertAnalyticsRuleRaw(requestParameters: UpsertAnalyticsRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnalyticsRule>> {
        if (requestParameters['ruleName'] == null) {
            throw new runtime.RequiredError(
                'ruleName',
                'Required parameter "ruleName" was null or undefined when calling upsertAnalyticsRule().'
            );
        }

        if (requestParameters['analyticsRuleUpdate'] == null) {
            throw new runtime.RequiredError(
                'analyticsRuleUpdate',
                'Required parameter "analyticsRuleUpdate" was null or undefined when calling upsertAnalyticsRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/analytics/rules/{ruleName}`;
        urlPath = urlPath.replace(`{${"ruleName"}}`, encodeURIComponent(String(requestParameters['ruleName'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AnalyticsRuleUpdateToJSON(requestParameters['analyticsRuleUpdate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalyticsRuleFromJSON(jsonValue));
    }

    /**
     * Upserts an analytics rule with the given name.
     * Upserts an analytics rule
     */
    async upsertAnalyticsRule(requestParameters: UpsertAnalyticsRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnalyticsRule> {
        const response = await this.upsertAnalyticsRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
