/* tslint:disable */
/* eslint-disable */
/**
 * Typesense API
 * An open source search engine for building delightful search experiences.
 *
 * The version of the OpenAPI document: 30.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  APIStatsResponse,
  SchemaChangeStatus,
  SuccessStatus,
  ToggleSlowRequestLogRequest,
} from '../models/index';
import {
    APIStatsResponseFromJSON,
    APIStatsResponseToJSON,
    SchemaChangeStatusFromJSON,
    SchemaChangeStatusToJSON,
    SuccessStatusFromJSON,
    SuccessStatusToJSON,
    ToggleSlowRequestLogRequestFromJSON,
    ToggleSlowRequestLogRequestToJSON,
} from '../models/index';

export interface TakeSnapshotRequest {
    snapshotPath: string;
}

export interface ToggleSlowRequestLogOperationRequest {
    toggleSlowRequestLogRequest?: ToggleSlowRequestLogRequest;
}

/**
 * 
 */
export class OperationsApi extends runtime.BaseAPI {

    /**
     * Clear the cached responses of search requests that are sent with `use_cache` parameter in the LRU cache.
     * Clear the cached responses of search requests in the LRU cache.
     */
    async clearCacheRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/operations/cache/clear`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessStatusFromJSON(jsonValue));
    }

    /**
     * Clear the cached responses of search requests that are sent with `use_cache` parameter in the LRU cache.
     * Clear the cached responses of search requests in the LRU cache.
     */
    async clearCache(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessStatus> {
        const response = await this.clearCacheRaw(initOverrides);
        return await response.value();
    }

    /**
     * Typesense uses RocksDB to store your documents on the disk. If you do frequent writes or updates, you could benefit from running a compaction of the underlying RocksDB database. This could reduce the size of the database and decrease read latency. While the database will not block during this operation, we recommend running it during off-peak hours.
     * Compacting the on-disk database
     */
    async compactDbRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/operations/db/compact`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessStatusFromJSON(jsonValue));
    }

    /**
     * Typesense uses RocksDB to store your documents on the disk. If you do frequent writes or updates, you could benefit from running a compaction of the underlying RocksDB database. This could reduce the size of the database and decrease read latency. While the database will not block during this operation, we recommend running it during off-peak hours.
     * Compacting the on-disk database
     */
    async compactDb(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessStatus> {
        const response = await this.compactDbRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns the status of any ongoing schema change operations. If no schema changes are in progress, returns an empty response.
     * Get the status of in-progress schema change operations
     */
    async getSchemaChangesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemaChangeStatus>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/operations/schema_changes`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemaChangeStatusFromJSON));
    }

    /**
     * Returns the status of any ongoing schema change operations. If no schema changes are in progress, returns an empty response.
     * Get the status of in-progress schema change operations
     */
    async getSchemaChanges(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemaChangeStatus>> {
        const response = await this.getSchemaChangesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the stats about API endpoints.
     * Get stats about API endpoints.
     */
    async retrieveAPIStatsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<APIStatsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/stats.json`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => APIStatsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the stats about API endpoints.
     * Get stats about API endpoints.
     */
    async retrieveAPIStats(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<APIStatsResponse> {
        const response = await this.retrieveAPIStatsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the metrics.
     * Get current RAM, CPU, Disk & Network usage metrics.
     */
    async retrieveMetricsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/metrics.json`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Retrieve the metrics.
     * Get current RAM, CPU, Disk & Network usage metrics.
     */
    async retrieveMetrics(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.retrieveMetricsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Creates a point-in-time snapshot of a Typesense node\'s state and data in the specified directory. You can then backup the snapshot directory that gets created and later restore it as a data directory, as needed.
     * Creates a point-in-time snapshot of a Typesense node\'s state and data in the specified directory.
     */
    async takeSnapshotRaw(requestParameters: TakeSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessStatus>> {
        if (requestParameters['snapshotPath'] == null) {
            throw new runtime.RequiredError(
                'snapshotPath',
                'Required parameter "snapshotPath" was null or undefined when calling takeSnapshot().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['snapshotPath'] != null) {
            queryParameters['snapshot_path'] = requestParameters['snapshotPath'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/operations/snapshot`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessStatusFromJSON(jsonValue));
    }

    /**
     * Creates a point-in-time snapshot of a Typesense node\'s state and data in the specified directory. You can then backup the snapshot directory that gets created and later restore it as a data directory, as needed.
     * Creates a point-in-time snapshot of a Typesense node\'s state and data in the specified directory.
     */
    async takeSnapshot(requestParameters: TakeSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessStatus> {
        const response = await this.takeSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enable logging of requests that take over a defined threshold of time. Default is `-1` which disables slow request logging. Slow requests are logged to the primary log file, with the prefix SLOW REQUEST.
     * Toggle Slow Request Log
     */
    async toggleSlowRequestLogRaw(requestParameters: ToggleSlowRequestLogOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/config`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ToggleSlowRequestLogRequestToJSON(requestParameters['toggleSlowRequestLogRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessStatusFromJSON(jsonValue));
    }

    /**
     * Enable logging of requests that take over a defined threshold of time. Default is `-1` which disables slow request logging. Slow requests are logged to the primary log file, with the prefix SLOW REQUEST.
     * Toggle Slow Request Log
     */
    async toggleSlowRequestLog(requestParameters: ToggleSlowRequestLogOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessStatus> {
        const response = await this.toggleSlowRequestLogRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Triggers a follower node to initiate the raft voting process, which triggers leader re-election. The follower node that you run this operation against will become the new leader, once this command succeeds.
     * Triggers a follower node to initiate the raft voting process, which triggers leader re-election.
     */
    async voteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-TYPESENSE-API-KEY"] = await this.configuration.apiKey("X-TYPESENSE-API-KEY"); // api_key_header authentication
        }


        let urlPath = `/operations/vote`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessStatusFromJSON(jsonValue));
    }

    /**
     * Triggers a follower node to initiate the raft voting process, which triggers leader re-election. The follower node that you run this operation against will become the new leader, once this command succeeds.
     * Triggers a follower node to initiate the raft voting process, which triggers leader re-election.
     */
    async vote(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessStatus> {
        const response = await this.voteRaw(initOverrides);
        return await response.value();
    }

}
